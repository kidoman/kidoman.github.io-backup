<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: node.js | Karan Misra]]></title>
  <link href="http://kidoman.io/tags/node-dot-js/atom.xml" rel="self"/>
  <link href="http://kidoman.io/"/>
  <updated>2014-05-12T20:15:18+05:30</updated>
  <id>http://kidoman.io/</id>
  <author>
    <name><![CDATA[Karan Misra]]></name>
    <email><![CDATA[karan.misra@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[node.js in action: Learnings]]></title>
    <link href="http://kidoman.io/engineering/node-dot-js-in-action-learnings.html"/>
    <updated>2013-05-31T01:58:00+05:30</updated>
    <id>http://kidoman.io/engineering/node-dot-js-in-action-learnings</id>
    <content type="html"><![CDATA[<p><img src="/images/node.js.png" title="nodejs" ></p>

<p>I recently gave a talk on node.js at work&hellip; the talk was surprisingly well attended. It was scheduled to start at 1 PM. At around 1:02 PM, I was alone in the room with not another soul in sight. The room filled to the brim in the next 10 minutes. Last count = 33</p>

<h1>Link to the talk</h1>

<p><a href="http://goo.gl/Pcz2wQ">click</a></p>

<h1>The Talk</h1>

<p>The theme of the talk was to get people excited about the node.js work we were doing for a large enterprise client. Almost 9 months into development, we had figured out a tonne of patterns and idioms and had actually started becoming productive with it. Talking about the hurdles faced during the non avoidable learning curve seemed like a sensible thing to do.</p>

<h2>Tech Stack</h2>

<p>Although I cannot reveal any actual URLs atm, the stack of the application we are developing is as follows:</p>

<ul>
<li>node.js (Platform)</li>
<li>Express (Web Server)</li>
<li>Sequelize (ORM)</li>
<li>MySQL (Database)</li>
<li>Q (Promises)</li>
<li>Mocha/Sinon/Chai (and their -as-promised bretheren, for TDD)</li>
<li>Grunt (Command runner)</li>
<li>Coffee-Resque (For background jobs)</li>
<li>Socket.io (For realtime tracking of connected clients)</li>
<li>Redis (As a datastore for our generated socket.io handshake tokens)</li>
<li>connect-assetmanager (For managing our assets; <strong>update</strong> we have now replaced this with our own hand rolled solution)</li>
</ul>


<h2>Promises to Keep: Q</h2>

<p>I think it is essential for any new node.js project to base itself on a solid promises library. As indicated above, the library of choice for us was Q. I would go out on a limb and say this &ndash; &ldquo;Avoiding callback hell is probably the least interesting feature of Q.&rdquo;</p>

<p>Q allows us to beautifully structure our code without excessive &ldquo;pyramiding.&rdquo; You still end up with a few nested promises from time to time, but that is also avoidable with judicious usage of Q.spread.</p>

<h2>Testing</h2>

<p>Equally important is the need to get the TDD/BDD pattern flowing right from get go. Mocha/Sinon/Chai allow BDD in JavaScript to look almost as elegant as RSpec (which I consider to be the holy grail of developer friendly BDD.) Being smart and using the -as-promised utility node modules will also save you a lot of grief and restore a sense of sanity to the test cases (you can then essentially start returning promises of future asserts from your test cases, instead of having to call a <strong>done()</strong> at the end to signal the end.)</p>

<h2>Scaling and Deployment</h2>

<p>Our dreams of serving a million requests from a single node.js process were quickly shattered when we discovered a pegged 100% CPU (on a single core.) Besides trying to fix the main issue (which turned out to be the MySQL driver being used by sequelize) we also spent some time getting the <a href="http://unicorn.bogomips.org/">unicornification</a> of node.js right. We ended up with a master-slave arrangement which allowed us to scale our application to N-1 cores (where N is the total number of cores available in the machine.) Common sense dictated the <strong>-1</strong> part (to leave a core aside for the kernel and various sub systems.)</p>

<p>Figuring our deployments was also fun. Although there was some talk of building and deploying a .rpm (our target Linux distribution was CentOS 6.4), the general lack of time lead us to adapt a git based deployment mechanism. Any SHA is a good candidate for deployment to any of our environments. We obviously ended up tagging the good ones.</p>

<h2>Conclusion</h2>

<p>We really went out on a limb here by using node.js for the project when we did not actually have much in house expertise on the same. However, the effort has redeemed itself many fold. A lot of people have successfully managed to <strong>get</strong> &ldquo;concurrent programming&rdquo; as a result. Coming out from the comfort zone of RoR, .NET and Java also possibly has changed the course of their lives for ever! :)</p>
]]></content>
  </entry>
  
</feed>
